#!/bin/bash
# =============================================================================
# Water-Controller Bootstrap - Docker Deployment Functions
# =============================================================================
# Docker-specific deployment, service creation, and container management.
# Depends on: constants.sh, logging.sh, helpers.sh, validation.sh, staging.sh

# Prevent double-sourcing
[[ -n "${_WTC_DOCKER_LOADED:-}" ]] && return 0
_WTC_DOCKER_LOADED=1

# =============================================================================
# Utility Functions
# =============================================================================

# Generate secure random password
generate_password() {
    local length="${1:-24}"

    # Try openssl first (most common)
    if command -v openssl &>/dev/null; then
        openssl rand -base64 "$length" | tr -d '\n'
        return 0
    fi

    # Fall back to /dev/urandom
    if [[ -r /dev/urandom ]]; then
        tr -dc 'A-Za-z0-9!@#$%^&*' < /dev/urandom | head -c "$length"
        return 0
    fi

    # Last resort: use date and random
    echo "$(date +%s)${RANDOM}${RANDOM}" | sha256sum | head -c "$length"
}

# =============================================================================
# Health Check Functions
# =============================================================================

# Wait for container health checks
wait_for_health_checks() {
    local docker_dir="$1"
    local max_wait="${2:-120}"  # 2 minutes default

    log_step "Waiting for services to become healthy..."

    local start_time
    start_time=$(date +%s)
    local timeout_time=$((start_time + max_wait))

    local services=("wtc-database" "wtc-api" "wtc-ui" "wtc-loki" "wtc-grafana")
    local healthy_services=()

    while true; do
        local all_healthy=true
        healthy_services=()

        for svc in "${services[@]}"; do
            local health
            health=$(docker inspect --format='{{.State.Health.Status}}' "$svc" 2>/dev/null || echo "starting")

            if [[ "$health" == "healthy" ]]; then
                healthy_services+=("$svc")
            else
                all_healthy=false
            fi
        done

        if [[ "$all_healthy" == "true" ]]; then
            log_info "All services are healthy (${#healthy_services[@]}/${#services[@]})"
            return 0
        fi

        local current_time
        current_time=$(date +%s)
        if [[ "$current_time" -ge "$timeout_time" ]]; then
            log_warn "Timeout waiting for services to become healthy"
            log_info "Healthy services: ${#healthy_services[@]}/${#services[@]}"
            return 1
        fi

        log_debug "Waiting for services... (${#healthy_services[@]}/${#services[@]} healthy)"
        sleep 5
    done
}

# Verify endpoints are responding
verify_endpoints() {
    local api_port="${WTC_API_PORT:-8000}"
    local ui_port="${WTC_UI_PORT:-8080}"
    local grafana_port="${WTC_GRAFANA_PORT:-3000}"

    log_step "Verifying service endpoints..."

    local errors=0

    # Check API health endpoint
    if curl -sf "http://localhost:$api_port/health" >/dev/null 2>&1; then
        log_info "API endpoint responding (port $api_port)"
    else
        log_error "API endpoint not responding (port $api_port)"
        errors=$((errors + 1))
    fi

    # Check UI
    if curl -sf "http://localhost:$ui_port" >/dev/null 2>&1; then
        log_info "UI endpoint responding (port $ui_port)"
    else
        log_error "UI endpoint not responding (port $ui_port)"
        errors=$((errors + 1))
    fi

    # Check Grafana
    if curl -sf "http://localhost:$grafana_port/api/health" >/dev/null 2>&1; then
        log_info "Grafana endpoint responding (port $grafana_port)"
    else
        log_warn "Grafana endpoint not responding yet (port $grafana_port)"
    fi

    return $errors
}

# =============================================================================
# Systemd Service Creation
# =============================================================================

# Create systemd service for auto-start
create_systemd_service() {
    local docker_dir="$1"
    local service_file="/etc/systemd/system/${WTC_DOCKER_SERVICE}.service"
    local env_file="$docker_dir/.env"

    log_step "Creating systemd service for auto-start on boot..."

    # Create .env file with required environment variables for docker compose
    log_info "Creating environment file: $env_file"
    {
        echo "# Water-Controller Docker Environment Variables"
        echo "# Auto-generated by bootstrap.sh"
        echo "# $(date -u +%Y-%m-%dT%H:%M:%SZ)"
        echo ""
        echo "GRAFANA_PASSWORD=${GRAFANA_PASSWORD}"
        echo "DB_PASSWORD=${DB_PASSWORD}"
        echo ""
        echo "# Port configuration (sourced from ports.env if exists)"
        echo "WTC_API_PORT=${WTC_API_PORT:-8000}"
        echo "WTC_UI_PORT=${WTC_UI_PORT:-8080}"
        echo "WTC_GRAFANA_PORT=${WTC_GRAFANA_PORT:-3000}"
        echo "WTC_DB_PORT=${WTC_DB_PORT:-5432}"
        echo "WTC_DOCKER_UI_INTERNAL_PORT=${WTC_DOCKER_UI_INTERNAL_PORT:-3000}"
        echo ""
        echo "# Network interface (empty = auto-detect)"
        echo "WTC_INTERFACE=${WTC_INTERFACE:-}"
    } | run_privileged tee "$env_file" > /dev/null
    run_privileged chmod 600 "$env_file"

    # Discovery: Find docker binary path at install time
    local docker_bin
    docker_bin=$(command -v docker)
    if [[ -z "$docker_bin" ]]; then
        log_error "Cannot find docker binary for systemd unit"
        return 1
    fi
    log_debug "Docker binary discovered at: $docker_bin"

    local service_content
    service_content=$(cat <<EOF
[Unit]
Description=Water-Controller Docker Stack
Requires=docker.service
After=docker.service network-online.target
Wants=network-online.target

[Service]
Type=oneshot
RemainAfterExit=yes
WorkingDirectory=$docker_dir
EnvironmentFile=$env_file
# Docker path discovered at install time: $docker_bin
ExecStart=$docker_bin compose up -d
ExecStop=$docker_bin compose down
TimeoutStartSec=300
TimeoutStopSec=120

[Install]
WantedBy=multi-user.target
EOF
)

    echo "$service_content" | run_privileged tee "$service_file" > /dev/null

    # Enable service
    run_privileged systemctl daemon-reload
    run_privileged systemctl enable "${WTC_DOCKER_SERVICE}.service"

    log_info "Systemd service created and enabled for auto-start"
}

# Create quick commands helper script
create_quick_commands() {
    local install_dir="$1"
    local commands_file="$install_dir/docker-commands.sh"

    log_step "Creating quick commands helper..."

    local commands_content
    commands_content=$(cat <<'EOF'
#!/bin/bash
# Water-Controller Docker Quick Commands

DOCKER_DIR="/opt/water-controller/docker"

alias wtc-status='docker compose -f $DOCKER_DIR/docker-compose.yml ps'
alias wtc-logs='docker compose -f $DOCKER_DIR/docker-compose.yml logs -f'
alias wtc-restart='docker compose -f $DOCKER_DIR/docker-compose.yml restart'
alias wtc-stop='docker compose -f $DOCKER_DIR/docker-compose.yml stop'
alias wtc-start='docker compose -f $DOCKER_DIR/docker-compose.yml start'
alias wtc-down='docker compose -f $DOCKER_DIR/docker-compose.yml down'
alias wtc-pull='docker compose -f $DOCKER_DIR/docker-compose.yml pull'
alias wtc-rebuild='docker compose -f $DOCKER_DIR/docker-compose.yml up -d --build'

echo "Water-Controller Docker Commands loaded:"
echo "  wtc-status   - Show container status"
echo "  wtc-logs     - Follow container logs"
echo "  wtc-restart  - Restart all containers"
echo "  wtc-stop     - Stop all containers"
echo "  wtc-start    - Start all containers"
echo "  wtc-down     - Stop and remove containers"
echo "  wtc-pull     - Pull latest images"
echo "  wtc-rebuild  - Rebuild and restart containers"
EOF
)

    echo "$commands_content" | run_privileged tee "$commands_file" > /dev/null
    run_privileged chmod +x "$commands_file"

    log_info "Quick commands helper created: $commands_file"
    log_info "To use: source $commands_file"
}

# =============================================================================
# Docker Cleanup
# =============================================================================

# Cleanup partial Docker install on failure
cleanup_docker_partial() {
    log_warn "Cleaning up partial Docker installation..."
    if command -v docker &>/dev/null && docker info &>/dev/null; then
        # Stop and remove containers from this project
        local containers
        containers=$(docker ps -aq --filter "name=wtc-" 2>/dev/null || true)
        if [[ -n "$containers" ]]; then
            docker stop $containers 2>/dev/null || true
            docker rm -f $containers 2>/dev/null || true
        fi
    fi
}

# =============================================================================
# Main Docker Install Function
# =============================================================================

# Clean up existing WTC containers and processes
cleanup_existing_wtc() {
    log_step "Cleaning up existing WTC installation..."

    # Stop and remove existing WTC containers (regardless of state)
    local containers
    containers=$(docker ps -a --filter "name=wtc-" --format "{{.Names}}" 2>/dev/null || true)
    if [[ -n "$containers" ]]; then
        log_info "Stopping existing WTC containers..."
        echo "$containers" | xargs -r docker stop 2>/dev/null || true
        echo "$containers" | xargs -r docker rm -f 2>/dev/null || true
    fi

    # Run docker compose down if compose file exists
    if [[ -f "/opt/water-controller/docker/docker-compose.yml" ]]; then
        log_info "Running docker compose down..."
        (cd /opt/water-controller/docker && docker compose down --remove-orphans 2>/dev/null) || true
    fi

    # Clean up stale shared memory
    if [[ -e "/dev/shm/wtc_shared_memory" ]]; then
        log_info "Removing stale shared memory..."
        rm -f /dev/shm/wtc_shared_memory 2>/dev/null || true
    fi

    # Kill any orphan controller processes (baremetal leftovers)
    if pgrep -f "water_treat_controller" >/dev/null 2>&1; then
        log_info "Killing orphan controller processes..."
        pkill -9 -f "water_treat_controller" 2>/dev/null || true
        sleep 1
    fi

    log_info "Cleanup complete"
}

# Run Docker deployment
do_docker_install() {
    log_step "Starting Docker deployment..."

    # Set up cleanup trap for partial failure
    local docker_install_failed="false"
    trap 'docker_install_failed="true"' ERR

    # Clean up any existing installation first
    cleanup_existing_wtc

    # Pre-deployment checks (non-blocking, warnings only)
    check_docker_resources || log_warn "Resource checks failed, proceeding anyway..."
    check_port_conflicts || log_warn "Port conflicts detected, proceeding anyway..."

    # Validate package-lock.json if repo is already cloned
    if [[ -d "/opt/water-controller/web/ui" ]]; then
        validate_package_lock "/opt/water-controller/web/ui" || log_warn "Package lock validation failed"
    fi

    # Find docker directory
    local docker_dir=""
    local repo_dir=""
    if [[ -d "./docker" ]]; then
        # Running from within repo directory - pull latest
        docker_dir="./docker"
        repo_dir="."
        log_info "Running from repo directory, pulling latest changes..."
        git pull origin main 2>/dev/null || log_warn "Could not pull latest (may be offline)"
    else
        # Always clone fresh to ensure we have latest code
        # This fixes issues where /opt/water-controller has stale Dockerfiles
        local staging_dir
        staging_dir=$(create_staging_dir "docker-install")
        register_cleanup "$staging_dir"

        clone_to_staging "$staging_dir" "main" || return 1
        docker_dir="$staging_dir/repo/docker"
        repo_dir="$staging_dir/repo"

        # Copy to persistent location (including hidden files)
        log_info "Installing to /opt/water-controller..."
        local mkdir_result
        if ! mkdir_result=$(run_privileged mkdir -p /opt/water-controller 2>&1); then
            log_error "Failed to create /opt/water-controller: $mkdir_result"
            return 1
        fi
        # Remove old files first to ensure clean install
        if [[ -d "/opt/water-controller/docker" ]]; then
            log_info "Removing old installation files..."
            run_privileged rm -rf /opt/water-controller/docker /opt/water-controller/web /opt/water-controller/src 2>/dev/null || true
        fi
        if ! run_privileged cp -a "$staging_dir/repo/." /opt/water-controller/; then
            log_error "Failed to copy repository to /opt/water-controller"
            return 1
        fi
        docker_dir="/opt/water-controller/docker"
        repo_dir="/opt/water-controller"
    fi

    log_info "Using Docker directory: $docker_dir"

    # Source ports.env if it exists
    local ports_env_file=""
    if [[ -f "$docker_dir/../config/ports.env" ]]; then
        ports_env_file="$docker_dir/../config/ports.env"
    elif [[ -f "./config/ports.env" ]]; then
        ports_env_file="./config/ports.env"
    fi

    if [[ -n "$ports_env_file" ]]; then
        log_info "Loading port configuration from: $ports_env_file"
        # Export variables from ports.env
        set -a
        source "$ports_env_file"
        set +a
    fi

    # Generate required passwords if not already set
    if [[ -z "${GRAFANA_PASSWORD:-}" ]]; then
        export GRAFANA_PASSWORD=$(generate_password 24)
    fi

    if [[ -z "${DB_PASSWORD:-}" ]]; then
        export DB_PASSWORD=$(generate_password 32)
    fi

    # Save passwords to PERSISTENT location
    local creds_file="/opt/water-controller/config/.docker-credentials"
    log_info "Configuring service credentials..."
    run_privileged mkdir -p "$(dirname "$creds_file")"
    {
        echo "# Water-Controller Docker Credentials"
        echo "# Generated: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
        echo "# KEEP THIS FILE SECURE - Contains passwords"
        echo ""
        echo "GRAFANA_PASSWORD=$GRAFANA_PASSWORD"
        echo "DB_PASSWORD=$DB_PASSWORD"
        echo ""
        echo "# Grafana URL: http://localhost:\${WTC_GRAFANA_PORT:-3000}"
        echo "# Grafana User: admin"
        echo "# Grafana Password: (see above)"
    } | run_privileged tee "$creds_file" > /dev/null
    run_privileged chmod 600 "$creds_file"

    # Build images with visible progress
    log_step "Building Docker images (this may take 5-10 minutes)..."
    log_info "Building: api, ui, controller (3 images)"

    # Discovery: Verify docker directory exists and is accessible
    if [[ ! -d "$docker_dir" ]]; then
        log_error "Docker directory not found: $docker_dir"
        log_info "  Expected docker-compose.yml at: $docker_dir/docker-compose.yml"
        return 1
    fi
    if [[ ! -f "$docker_dir/docker-compose.yml" ]]; then
        log_error "docker-compose.yml not found in: $docker_dir"
        log_info "  Directory contents: $(ls -la "$docker_dir" 2>&1 | head -5)"
        return 1
    fi
    log_debug "Docker directory verified: $docker_dir"

    (
        cd "$docker_dir" || exit 1
        export GRAFANA_PASSWORD="$GRAFANA_PASSWORD"
        export DB_PASSWORD="$DB_PASSWORD"

        docker compose build --no-cache --progress=plain 2>&1 | while IFS= read -r line; do
            # Show build step numbers only (e.g., "#7" from "#7 [api 1/8] FROM docker...")
            if echo "$line" | grep -qE "^#[0-9]+ \["; then
                step=$(echo "$line" | grep -oE "^#[0-9]+")
                echo "[BUILD] $step" >&2
            # Show image building status
            elif echo "$line" | grep -qE "Image docker-[a-z]+ Building"; then
                echo "[BUILD] $line" >&2
            # Show completion/finish messages
            elif echo "$line" | grep -qE "writing image|FINISHED|exporting"; then
                echo "[BUILD] $line" >&2
            # Always show errors
            elif echo "$line" | grep -qiE "error|ERROR|failed|FAILED|fatal"; then
                echo "[BUILD ERROR] $line" >&2
            fi
        done
    ) || {
        log_error "Docker image build failed"
        log_info "Check logs above for build errors"
        log_info "Common issues:"
        log_info "  - Missing build dependencies (should be auto-installed)"
        log_info "  - Network connectivity (required for package downloads)"
        log_info "  - Insufficient disk space"
        cleanup_docker_partial
        return 1
    }

    # Start containers (docker_dir already verified above during build step)
    # Note: POSIX shared memory for controller-API IPC is created automatically
    # by the controller process. Both containers use ipc: host to share the
    # host's IPC namespace where /dev/shm/wtc_shared_memory is created.
    log_step "Starting containers..."
    (
        cd "$docker_dir" || { echo "ERROR: Cannot access $docker_dir" >&2; exit 1; }
        export GRAFANA_PASSWORD="$GRAFANA_PASSWORD"
        export DB_PASSWORD="$DB_PASSWORD"

        docker compose up -d --force-recreate
    )

    local result=$?
    if [[ $result -ne 0 ]]; then
        log_error "Docker deployment failed"
        cleanup_docker_partial
        return $result
    fi

    # Wait for health checks
    wait_for_health_checks "$docker_dir" 120

    # Verify endpoints
    verify_endpoints

    # Fix database authentication if needed
    log_step "Ensuring database authentication is configured..."
    if [[ -x "$INSTALL_DIR/scripts/fix-database-auth.sh" ]]; then
        "$INSTALL_DIR/scripts/fix-database-auth.sh" || log_warn "Database auth fix had warnings (check logs)"
    else
        log_warn "Database auth fix script not found, skipping"
    fi

    # Run comprehensive validation
    log_step "Running deployment validation..."
    if [[ -x "$INSTALL_DIR/scripts/validate-deployment.sh" ]]; then
        if "$INSTALL_DIR/scripts/validate-deployment.sh"; then
            log_info "Deployment validation passed"
        else
            log_warn "Deployment validation had failures (see above)"
        fi
    else
        log_warn "Validation script not found, skipping comprehensive validation"
    fi

    # Create systemd service for auto-start
    create_systemd_service "$docker_dir"

    # Create quick commands helper
    create_quick_commands "/opt/water-controller"

    # Display deployment summary
    log_info ""
    log_info "================================================================"
    log_info "          WATER-CONTROLLER DEPLOYMENT SUMMARY                  "
    log_info "================================================================"
    log_info ""
    log_info "Docker installed: $(docker --version | cut -d' ' -f3 | tr -d ',')"
    log_info "Docker Compose: $(docker compose version --short)"
    log_info "Containers started successfully"
    log_info "Auto-start enabled (systemd service)"
    log_info ""
    log_info "=== ACCESS POINTS ==="
    local ip_addr
    ip_addr=$(hostname -I 2>/dev/null | awk '{print $1}' || echo "localhost")
    log_info "  Web UI:      http://$ip_addr:${WTC_UI_PORT:-8080}"
    log_info "  API Docs:    http://$ip_addr:${WTC_API_PORT:-8000}/docs"
    log_info "  API Health:  http://$ip_addr:${WTC_API_PORT:-8000}/health"
    log_info "  Grafana:     http://$ip_addr:${WTC_GRAFANA_PORT:-3000}"
    log_info ""
    log_info "=== CREDENTIALS ==="
    log_info "  Grafana User:     admin"
    log_info "  Grafana Password: $GRAFANA_PASSWORD"
    log_info "  Credentials File: $creds_file"
    log_info ""
    log_info "=== MANAGEMENT COMMANDS ==="
    log_info "  Status:  docker compose -f $docker_dir/docker-compose.yml ps"
    log_info "  Logs:    docker compose -f $docker_dir/docker-compose.yml logs -f"
    log_info "  Restart: sudo systemctl restart $WTC_DOCKER_SERVICE"
    log_info "  Stop:    sudo systemctl stop $WTC_DOCKER_SERVICE"
    log_info ""
    log_info "  Quick commands: source /opt/water-controller/docker-commands.sh"
    log_info ""
    log_info "=== TROUBLESHOOTING ==="
    log_info "  Validate:  $INSTALL_DIR/scripts/validate-deployment.sh"
    log_info "  Fix Auth:  $INSTALL_DIR/scripts/fix-database-auth.sh"
    log_info "  Guide:     $INSTALL_DIR/docs/DEPLOYMENT_TROUBLESHOOTING.md"
    log_info ""
    log_info "=== NEXT STEPS ==="
    log_info "  1. Browse to http://$ip_addr:${WTC_UI_PORT:-8080}"
    log_info "  2. Save your Grafana password securely"
    log_info "  3. Configure firewall if accessing remotely"
    log_info "  4. Change default admin password (admin/admin)"
    log_info ""

    return 0
}
