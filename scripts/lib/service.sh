#!/bin/bash
#
# Water Treatment Controller - Service Configuration and systemd Integration
# Copyright (C) 2024-2025
# SPDX-License-Identifier: GPL-3.0-or-later
#
# This module provides systemd service generation, installation,
# and lifecycle management for the Water-Controller application.
#
# Tech Stack: Python/FastAPI with uvicorn or gunicorn
# Target: ARM/x86 SBCs running Debian-based Linux
#

# Prevent multiple sourcing
if [ -n "${_WTC_SERVICE_LOADED:-}" ]; then
    return 0
fi
_WTC_SERVICE_LOADED=1

# Source detection module for logging functions
: "${SCRIPT_DIR:=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)}"
if [ -f "$SCRIPT_DIR/detection.sh" ]; then
    # shellcheck source=detection.sh
    source "$SCRIPT_DIR/detection.sh"
fi

# =============================================================================
# Constants
# =============================================================================

readonly SERVICE_MODULE_VERSION="1.0.0"

# Service configuration
: "${SERVICE_NAME:=water-controller}"
readonly SERVICE_FILE="/etc/systemd/system/${SERVICE_NAME}.service"
: "${SERVICE_USER:=water-controller}"
: "${SERVICE_GROUP:=water-controller}"

# Paths
: "${INSTALL_BASE:=/opt/water-controller}"
: "${VENV_PATH:=$INSTALL_BASE/venv}"
: "${APP_PATH:=$INSTALL_BASE/app}"
: "${CONFIG_DIR:=/etc/water-controller}"
: "${DATA_DIR:=/var/lib/water-controller}"
: "${LOG_DIR:=/var/log/water-controller}"
: "${RUN_DIR:=/run/water-controller}"

# Default ports
: "${DEFAULT_API_PORT:=8000}"
: "${DEFAULT_HMI_PORT:=8080}"

# Frontend service configuration
readonly FRONTEND_SERVICE_NAME="${SERVICE_NAME}-frontend"
readonly FRONTEND_SERVICE_FILE="/etc/systemd/system/${FRONTEND_SERVICE_NAME}.service"
: "${WEB_PATH:=$INSTALL_BASE/web}"

# Timeouts
readonly SERVICE_START_TIMEOUT=30
readonly SERVICE_STOP_TIMEOUT=30
readonly HEALTH_CHECK_TIMEOUT=5

# =============================================================================
# Resource Calculation
# =============================================================================

# Calculate resource limits based on system RAM
# Sets: _MEMORY_MAX, _MEMORY_HIGH, _CPU_QUOTA, _WORKERS
_calculate_resources() {
    local total_ram_mb
    total_ram_mb="$(awk '/MemTotal/ {printf "%.0f", $2/1024}' /proc/meminfo 2>/dev/null || echo 1024)"

    local cpu_cores
    cpu_cores="$(nproc 2>/dev/null || echo 1)"

    # Memory limits based on available RAM
    if [ "$total_ram_mb" -lt 1024 ]; then
        # < 1GB RAM - very constrained
        _MEMORY_MAX="256M"
        _MEMORY_HIGH="200M"
        _WORKERS=1
    elif [ "$total_ram_mb" -lt 2048 ]; then
        # 1-2GB RAM - constrained
        _MEMORY_MAX="512M"
        _MEMORY_HIGH="400M"
        _WORKERS=1
    elif [ "$total_ram_mb" -lt 4096 ]; then
        # 2-4GB RAM - moderate
        _MEMORY_MAX="1G"
        _MEMORY_HIGH="800M"
        _WORKERS=2
    else
        # >= 4GB RAM - comfortable
        _MEMORY_MAX="2G"
        _MEMORY_HIGH="1600M"
        _WORKERS=4
    fi

    # CPU quota based on cores
    if [ "$cpu_cores" -eq 1 ]; then
        _CPU_QUOTA="100%"
    elif [ "$cpu_cores" -le 2 ]; then
        _CPU_QUOTA="150%"
    elif [ "$cpu_cores" -le 4 ]; then
        _CPU_QUOTA="200%"
    else
        _CPU_QUOTA="400%"
    fi

    # Limit workers based on cores
    if [ "$_WORKERS" -gt "$cpu_cores" ]; then
        _WORKERS=$cpu_cores
    fi

    log_debug "Calculated resources: MemoryMax=$_MEMORY_MAX, CPUQuota=$_CPU_QUOTA, Workers=$_WORKERS"
}

# =============================================================================
# Service Unit Generation
# =============================================================================

# Generate systemd service unit file
# Input: platform (optional), workers (optional)
# Returns: 0 on success, prints service unit content
generate_service_unit() {
    local platform="${1:-generic}"
    local workers="${2:-auto}"

    # Note: All logging in this function goes to stderr to avoid
    # mixing with the service unit output on stdout
    echo "[DEBUG] Generating systemd service unit..." >&2

    # Calculate resource limits
    _calculate_resources

    # Use provided workers or calculated value
    if [ "$workers" = "auto" ]; then
        workers="$_WORKERS"
    fi

    # Determine the app module path
    local app_module="app.main:app"
    if [ -f "$APP_PATH/main.py" ]; then
        app_module="main:app"
    elif [ -f "$APP_PATH/app/main.py" ]; then
        app_module="app.main:app"
    fi

    echo "[DEBUG] App module: $app_module" >&2
    echo "[DEBUG] Workers: $workers" >&2

    # Generate service unit
    cat << EOF
# Water-Controller SCADA System Service
# Generated by installation script v${SERVICE_MODULE_VERSION}
# Platform: ${platform}

[Unit]
Description=Water-Controller SCADA System
Documentation=https://github.com/mwilco03/Water-Controller
After=network-online.target
Wants=network-online.target
StartLimitIntervalSec=300
StartLimitBurst=5

[Service]
Type=exec
User=${SERVICE_USER}
Group=${SERVICE_GROUP}
WorkingDirectory=${APP_PATH}

# Environment
Environment="PYTHONUNBUFFERED=1"
Environment="PYTHONDONTWRITEBYTECODE=1"
Environment="CONFIG_PATH=${CONFIG_DIR}/config.yaml"
Environment="DATA_DIR=${DATA_DIR}"
Environment="LOG_DIR=${LOG_DIR}"
EnvironmentFile=-${CONFIG_DIR}/environment

# Runtime directory
RuntimeDirectory=${SERVICE_NAME}
RuntimeDirectoryMode=0755

# Start command - uvicorn with workers
ExecStart=${VENV_PATH}/bin/uvicorn ${app_module} \\
    --host 0.0.0.0 \\
    --port ${DEFAULT_API_PORT} \\
    --workers ${workers} \\
    --log-config ${CONFIG_DIR}/logging.yaml \\
    --access-log \\
    --proxy-headers

# Alternative: gunicorn (uncomment to use instead of uvicorn)
# ExecStart=${VENV_PATH}/bin/gunicorn ${app_module} \\
#     --bind 0.0.0.0:${DEFAULT_API_PORT} \\
#     --workers ${workers} \\
#     --worker-class uvicorn.workers.UvicornWorker \\
#     --access-logfile - \\
#     --error-logfile - \\
#     --capture-output

# Reload command
ExecReload=/bin/kill -HUP \$MAINPID

# Graceful shutdown
KillMode=mixed
KillSignal=SIGTERM
TimeoutStopSec=${SERVICE_STOP_TIMEOUT}s
FinalKillSignal=SIGKILL

# Restart policy
Restart=on-failure
RestartSec=10s
RestartPreventExitStatus=255

# Resource limits
MemoryMax=${_MEMORY_MAX}
MemoryHigh=${_MEMORY_HIGH}
CPUQuota=${_CPU_QUOTA}
TasksMax=256

# File descriptor limit
LimitNOFILE=65536

# Logging
StandardOutput=journal
StandardError=journal
SyslogIdentifier=${SERVICE_NAME}

# Security hardening
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ProtectKernelTunables=true
ProtectKernelModules=true
ProtectControlGroups=true
RestrictRealtime=true
RestrictSUIDSGID=true
LockPersonality=true

# Allow access to required paths
ReadWritePaths=${DATA_DIR} ${LOG_DIR} ${RUN_DIR}
ReadOnlyPaths=${CONFIG_DIR} ${VENV_PATH} ${APP_PATH}

# Network access
RestrictAddressFamilies=AF_INET AF_INET6 AF_UNIX AF_NETLINK

# Capabilities - drop all, add only what's needed
CapabilityBoundingSet=
AmbientCapabilities=

# For PROFINET raw socket access (if needed), uncomment:
# CapabilityBoundingSet=CAP_NET_RAW CAP_NET_ADMIN
# AmbientCapabilities=CAP_NET_RAW CAP_NET_ADMIN

[Install]
WantedBy=multi-user.target
EOF

    return 0
}

# Generate frontend (Next.js) systemd service unit file
# Returns: 0 on success, prints service unit content
generate_frontend_service_unit() {
    echo "[DEBUG] Generating frontend systemd service unit..." >&2

    # Calculate resource limits (reuse backend function)
    _calculate_resources

    # Use lower memory limits for frontend
    local frontend_memory_max
    local frontend_memory_high
    case "$_MEMORY_MAX" in
        "256M") frontend_memory_max="128M"; frontend_memory_high="100M" ;;
        "512M") frontend_memory_max="256M"; frontend_memory_high="200M" ;;
        "1G")   frontend_memory_max="512M"; frontend_memory_high="400M" ;;
        *)      frontend_memory_max="512M"; frontend_memory_high="400M" ;;
    esac

    # Generate service unit
    cat << EOF
# Water-Controller Frontend Service (Next.js HMI)
# Generated by installation script v${SERVICE_MODULE_VERSION}

[Unit]
Description=Water-Controller Frontend (Next.js HMI)
Documentation=https://github.com/mwilco03/Water-Controller
After=network-online.target ${SERVICE_NAME}.service
Wants=network-online.target
BindsTo=${SERVICE_NAME}.service
StartLimitIntervalSec=300
StartLimitBurst=5

[Service]
Type=exec
User=${SERVICE_USER}
Group=${SERVICE_GROUP}
WorkingDirectory=${WEB_PATH}

# Environment
Environment="NODE_ENV=production"
Environment="PORT=${DEFAULT_HMI_PORT}"
Environment="HOSTNAME=0.0.0.0"
Environment="NEXT_TELEMETRY_DISABLED=1"
EnvironmentFile=-${CONFIG_DIR}/environment

# Runtime directory
RuntimeDirectory=${FRONTEND_SERVICE_NAME}
RuntimeDirectoryMode=0755

# Start command - Next.js production server
ExecStart=/usr/bin/node ${WEB_PATH}/node_modules/.bin/next start -p ${DEFAULT_HMI_PORT} -H 0.0.0.0

# Graceful shutdown
KillMode=mixed
KillSignal=SIGTERM
TimeoutStopSec=${SERVICE_STOP_TIMEOUT}s
FinalKillSignal=SIGKILL

# Restart policy
Restart=on-failure
RestartSec=10s
RestartPreventExitStatus=255

# Resource limits (lower than backend)
MemoryMax=${frontend_memory_max}
MemoryHigh=${frontend_memory_high}
CPUQuota=${_CPU_QUOTA}
TasksMax=128

# File descriptor limit
LimitNOFILE=16384

# Logging
StandardOutput=journal
StandardError=journal
SyslogIdentifier=${FRONTEND_SERVICE_NAME}

# Security hardening
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ProtectKernelTunables=true
ProtectKernelModules=true
ProtectControlGroups=true
RestrictRealtime=true
RestrictSUIDSGID=true
LockPersonality=true

# Allow access to required paths
ReadWritePaths=${LOG_DIR}
ReadOnlyPaths=${WEB_PATH}

# Network access
RestrictAddressFamilies=AF_INET AF_INET6 AF_UNIX

# Capabilities - drop all
CapabilityBoundingSet=
AmbientCapabilities=

[Install]
WantedBy=multi-user.target
EOF

    return 0
}

# =============================================================================
# Service Installation
# =============================================================================

# Install frontend (Next.js) systemd service
# Returns: 0 on success, 4 on failure
install_frontend_service() {
    log_info "Installing frontend systemd service..."

    # Check if systemd is available
    if ! command -v systemctl >/dev/null 2>&1; then
        log_error "systemctl not found - systemd is required"
        return 4
    fi

    # Check if frontend is installed
    if [ ! -d "$WEB_PATH" ] || [ ! -f "$WEB_PATH/package.json" ]; then
        log_warn "Frontend not found at $WEB_PATH, skipping frontend service"
        return 0
    fi

    # Check for Next.js build
    if [ ! -d "$WEB_PATH/.next" ]; then
        log_warn "Frontend not built (.next not found), skipping frontend service"
        return 0
    fi

    # Backup existing service if present
    if [ -f "$FRONTEND_SERVICE_FILE" ]; then
        log_info "Backing up existing frontend service file..."
        local backup_file="${FRONTEND_SERVICE_FILE}.backup.$(date +%Y%m%d_%H%M%S)"
        sudo cp "$FRONTEND_SERVICE_FILE" "$backup_file" || {
            log_error "Failed to backup existing frontend service file"
            return 4
        }
        log_debug "Backup created: $backup_file"
    fi

    # Generate service unit
    local temp_file
    temp_file="$(mktemp)"

    generate_frontend_service_unit > "$temp_file" || {
        log_error "Failed to generate frontend service unit"
        rm -f "$temp_file"
        return 4
    }

    # Install service file
    sudo cp "$temp_file" "$FRONTEND_SERVICE_FILE" || {
        log_error "Failed to install frontend service file"
        rm -f "$temp_file"
        return 4
    }
    rm -f "$temp_file"

    # Set permissions
    sudo chmod 644 "$FRONTEND_SERVICE_FILE"
    sudo chown root:root "$FRONTEND_SERVICE_FILE"

    # Reload systemd daemon
    log_info "Reloading systemd daemon..."
    if ! sudo systemctl daemon-reload; then
        log_error "Failed to reload systemd daemon"
        return 4
    fi

    # Verify service is recognized
    if ! systemctl list-unit-files "$FRONTEND_SERVICE_NAME.service" >/dev/null 2>&1; then
        log_error "Frontend service not recognized by systemd after installation"
        return 4
    fi

    log_info "Frontend service installed successfully: $FRONTEND_SERVICE_FILE"
    _log_write "INFO" "Frontend systemd service installed: $FRONTEND_SERVICE_FILE"

    return 0
}

# Clean up old/conflicting services
# This ensures a clean installation when upgrading
_cleanup_old_services() {
    log_debug "Checking for old/conflicting services..."

    # List of old service names that may conflict
    local old_services=(
        "water-controller-api"
        "water-controller-hmi"
        "water-controller-modbus"
    )

    for svc in "${old_services[@]}"; do
        if systemctl list-unit-files "${svc}.service" >/dev/null 2>&1; then
            log_info "Cleaning up old service: ${svc}"

            # Stop if running
            if systemctl is-active "${svc}.service" >/dev/null 2>&1; then
                sudo systemctl stop "${svc}.service" 2>/dev/null || true
            fi

            # Disable if enabled
            if systemctl is-enabled "${svc}.service" >/dev/null 2>&1; then
                sudo systemctl disable "${svc}.service" 2>/dev/null || true
            fi

            # Remove old service file
            if [ -f "/etc/systemd/system/${svc}.service" ]; then
                sudo rm -f "/etc/systemd/system/${svc}.service" 2>/dev/null || true
                log_debug "Removed: /etc/systemd/system/${svc}.service"
            fi
        fi
    done

    # Reload daemon after cleanup
    sudo systemctl daemon-reload 2>/dev/null || true
}

# Install systemd service
# Returns: 0 on success, 4 on failure
install_service() {
    local platform="${1:-generic}"
    local workers="${2:-auto}"

    log_info "Installing systemd service..."

    # Check if systemd is available
    if ! command -v systemctl >/dev/null 2>&1; then
        log_error "systemctl not found - systemd is required"
        return 4
    fi

    # Clean up old/conflicting services first
    _cleanup_old_services

    # Backup existing service if present
    if [ -f "$SERVICE_FILE" ]; then
        log_info "Backing up existing service file..."
        local backup_file="${SERVICE_FILE}.backup.$(date +%Y%m%d_%H%M%S)"
        sudo cp "$SERVICE_FILE" "$backup_file" || {
            log_error "Failed to backup existing service file"
            return 4
        }
        log_debug "Backup created: $backup_file"
    fi

    # Generate service unit
    local temp_file
    temp_file="$(mktemp)"

    generate_service_unit "$platform" "$workers" > "$temp_file" || {
        log_error "Failed to generate service unit"
        rm -f "$temp_file"
        return 4
    }

    # Install service file
    sudo cp "$temp_file" "$SERVICE_FILE" || {
        log_error "Failed to install service file"
        rm -f "$temp_file"
        return 4
    }
    rm -f "$temp_file"

    # Set permissions
    sudo chmod 644 "$SERVICE_FILE"
    sudo chown root:root "$SERVICE_FILE"

    # Reload systemd daemon
    log_info "Reloading systemd daemon..."
    if ! sudo systemctl daemon-reload; then
        log_error "Failed to reload systemd daemon"
        return 4
    fi

    # Verify service is recognized
    if ! systemctl list-unit-files "$SERVICE_NAME.service" >/dev/null 2>&1; then
        log_error "Service not recognized by systemd after installation"
        return 4
    fi

    log_info "Service installed successfully: $SERVICE_FILE"
    _log_write "INFO" "systemd service installed: $SERVICE_FILE"

    # Also install frontend service
    install_frontend_service || {
        log_warn "Frontend service installation failed (non-fatal)"
    }

    return 0
}

# =============================================================================
# Service Enable
# =============================================================================

# Enable service to start on boot
# Returns: 0 on success, 4 on failure
enable_service() {
    log_info "Enabling service..."

    if ! sudo systemctl enable "$SERVICE_NAME.service" 2>&1 | tee -a "$INSTALL_LOG_FILE"; then
        log_error "Failed to enable service"
        return 4
    fi

    # Verify enabled
    if ! systemctl is-enabled "$SERVICE_NAME.service" >/dev/null 2>&1; then
        log_error "Service enable verification failed"
        return 4
    fi

    log_info "Service enabled: $SERVICE_NAME"
    _log_write "INFO" "Service enabled for automatic start"

    # Also enable frontend service if it exists
    if [ -f "$FRONTEND_SERVICE_FILE" ]; then
        log_info "Enabling frontend service..."
        if sudo systemctl enable "$FRONTEND_SERVICE_NAME.service" 2>&1 | tee -a "$INSTALL_LOG_FILE"; then
            log_info "Frontend service enabled: $FRONTEND_SERVICE_NAME"
        else
            log_warn "Failed to enable frontend service (non-fatal)"
        fi
    fi

    return 0
}

# Disable service
# Returns: 0 on success
disable_service() {
    log_info "Disabling service..."

    if ! sudo systemctl disable "$SERVICE_NAME.service" 2>&1 | tee -a "$INSTALL_LOG_FILE"; then
        log_warn "Failed to disable service"
        return 1
    fi

    log_info "Service disabled"
    return 0
}

# =============================================================================
# Service Start
# =============================================================================

# Start service and wait for it to be active
# Returns: 0 on success, 4 on failure
start_service() {
    log_info "Starting service..."

    # Check if already running
    if systemctl is-active "$SERVICE_NAME.service" >/dev/null 2>&1; then
        log_info "Service is already running"
        return 0
    fi

    # Start the service
    if ! sudo systemctl start "$SERVICE_NAME.service" 2>&1 | tee -a "$INSTALL_LOG_FILE"; then
        log_error "Failed to start service"
        _capture_service_logs
        return 4
    fi

    # Wait for service to become active
    log_info "Waiting for service to become active..."
    local waited=0
    local poll_interval=2

    while [ $waited -lt $SERVICE_START_TIMEOUT ]; do
        if systemctl is-active "$SERVICE_NAME.service" >/dev/null 2>&1; then
            log_info "Service started successfully (took ${waited}s)"
            _log_write "INFO" "Service started successfully"

            # Also start frontend service if it exists
            if [ -f "$FRONTEND_SERVICE_FILE" ]; then
                log_info "Starting frontend service..."
                if sudo systemctl start "$FRONTEND_SERVICE_NAME.service" 2>&1 | tee -a "$INSTALL_LOG_FILE"; then
                    # Wait briefly for frontend to start
                    sleep 2
                    if systemctl is-active "$FRONTEND_SERVICE_NAME.service" >/dev/null 2>&1; then
                        log_info "Frontend service started successfully"
                    else
                        log_warn "Frontend service may not have started correctly"
                    fi
                else
                    log_warn "Failed to start frontend service (non-fatal)"
                fi
            fi

            return 0
        fi

        # Check if service failed
        if systemctl is-failed "$SERVICE_NAME.service" >/dev/null 2>&1; then
            log_error "Service failed to start"
            _capture_service_logs
            return 4
        fi

        sleep $poll_interval
        waited=$((waited + poll_interval))
        log_debug "Waiting for service... ($waited/$SERVICE_START_TIMEOUT seconds)"
    done

    log_error "Service start timed out after $SERVICE_START_TIMEOUT seconds"
    _capture_service_logs
    return 4
}

# Capture service logs for debugging
_capture_service_logs() {
    log_error "=== Recent service logs ==="
    journalctl -u "$SERVICE_NAME.service" -n 20 --no-pager 2>&1 | while read -r line; do
        log_error "  $line"
    done
    log_error "==========================="
}

# =============================================================================
# Service Stop
# =============================================================================

# Stop service gracefully
# Returns: 0 on success
stop_service() {
    log_info "Stopping service..."

    # Stop frontend service first if it exists
    if [ -f "$FRONTEND_SERVICE_FILE" ]; then
        if systemctl is-active "$FRONTEND_SERVICE_NAME.service" >/dev/null 2>&1; then
            log_info "Stopping frontend service..."
            sudo systemctl stop "$FRONTEND_SERVICE_NAME.service" 2>&1 | tee -a "$INSTALL_LOG_FILE" || true
        fi
    fi

    # Check if backend running
    if ! systemctl is-active "$SERVICE_NAME.service" >/dev/null 2>&1; then
        log_info "Service is not running"
        return 0
    fi

    # Stop the service
    if ! sudo systemctl stop "$SERVICE_NAME.service" 2>&1 | tee -a "$INSTALL_LOG_FILE"; then
        log_error "Failed to stop service"
        return 1
    fi

    # Wait for service to stop
    local waited=0
    local poll_interval=2

    while [ $waited -lt $SERVICE_STOP_TIMEOUT ]; do
        if ! systemctl is-active "$SERVICE_NAME.service" >/dev/null 2>&1; then
            log_info "Service stopped successfully"
            return 0
        fi

        sleep $poll_interval
        waited=$((waited + poll_interval))
    done

    log_warn "Service stop timed out, forcing..."
    sudo systemctl kill "$SERVICE_NAME.service" 2>/dev/null || true

    return 0
}

# Restart service
# Returns: 0 on success
restart_service() {
    log_info "Restarting service..."

    if ! sudo systemctl restart "$SERVICE_NAME.service" 2>&1 | tee -a "$INSTALL_LOG_FILE"; then
        log_error "Failed to restart service"
        _capture_service_logs
        return 4
    fi

    # Wait for service to become active
    local waited=0
    local poll_interval=2

    while [ $waited -lt $SERVICE_START_TIMEOUT ]; do
        if systemctl is-active "$SERVICE_NAME.service" >/dev/null 2>&1; then
            log_info "Service restarted successfully"
            return 0
        fi

        if systemctl is-failed "$SERVICE_NAME.service" >/dev/null 2>&1; then
            log_error "Service failed after restart"
            _capture_service_logs
            return 4
        fi

        sleep $poll_interval
        waited=$((waited + poll_interval))
    done

    log_error "Service restart timed out"
    return 4
}

# =============================================================================
# Service Health Check
# =============================================================================

# Check service health
# Returns: 0 if healthy, 5 if unhealthy
check_service_health() {
    log_info "Checking service health..."

    local failed=0
    local results=()

    # Check service is active
    if systemctl is-active "$SERVICE_NAME.service" >/dev/null 2>&1; then
        results+=("[OK] Service status: active")
    else
        results+=("[FAIL] Service status: not active")
        failed=1
    fi

    # Check service is enabled
    if systemctl is-enabled "$SERVICE_NAME.service" >/dev/null 2>&1; then
        results+=("[OK] Service enabled: yes")
    else
        results+=("[WARN] Service enabled: no")
    fi

    # Get service uptime
    local active_since
    active_since="$(systemctl show "$SERVICE_NAME.service" --property=ActiveEnterTimestamp 2>/dev/null | cut -d= -f2)"
    if [ -n "$active_since" ] && [ "$active_since" != "n/a" ]; then
        results+=("[INFO] Active since: $active_since")
    fi

    # Check for recent restarts
    local restart_count
    restart_count="$(systemctl show "$SERVICE_NAME.service" --property=NRestarts 2>/dev/null | cut -d= -f2)"
    if [ -n "$restart_count" ] && [ "$restart_count" != "0" ]; then
        results+=("[WARN] Restart count: $restart_count")
    else
        results+=("[OK] Restart count: 0")
    fi

    # Check process is running
    local main_pid
    main_pid="$(systemctl show "$SERVICE_NAME.service" --property=MainPID 2>/dev/null | cut -d= -f2)"
    if [ -n "$main_pid" ] && [ "$main_pid" != "0" ]; then
        if ps -p "$main_pid" >/dev/null 2>&1; then
            results+=("[OK] Main process: $main_pid")
        else
            results+=("[FAIL] Main process $main_pid not found")
            failed=1
        fi
    fi

    # Check uvicorn processes
    local uvicorn_count
    uvicorn_count="$(pgrep -c -f 'uvicorn' 2>/dev/null)" || uvicorn_count=0
    if [ "$uvicorn_count" -gt 0 ]; then
        results+=("[OK] Uvicorn processes: $uvicorn_count")
    else
        results+=("[WARN] No uvicorn processes found")
    fi

    # Check health endpoint if service is active
    if [ $failed -eq 0 ]; then
        log_debug "Checking health endpoint..."
        local health_url="http://localhost:${DEFAULT_API_PORT}/health"

        if command -v curl >/dev/null 2>&1; then
            local http_code
            http_code="$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout "$HEALTH_CHECK_TIMEOUT" "$health_url" 2>/dev/null || echo "000")"

            if [ "$http_code" = "200" ]; then
                results+=("[OK] Health endpoint: HTTP 200")
            elif [ "$http_code" = "000" ]; then
                # Try alternate endpoints
                for endpoint in "/api/health" "/api/v1/health" "/"; do
                    local alt_url="http://localhost:${DEFAULT_API_PORT}${endpoint}"
                    http_code="$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout "$HEALTH_CHECK_TIMEOUT" "$alt_url" 2>/dev/null || echo "000")"
                    if [ "$http_code" = "200" ]; then
                        results+=("[OK] Endpoint responding: $endpoint (HTTP 200)")
                        break
                    fi
                done
                if [ "$http_code" != "200" ]; then
                    results+=("[WARN] Health endpoint not responding")
                fi
            else
                results+=("[WARN] Health endpoint: HTTP $http_code")
            fi
        else
            results+=("[INFO] curl not available, skipping HTTP check")
        fi
    fi

    # Check for errors in recent logs
    local error_count
    error_count="$(journalctl -u "$SERVICE_NAME.service" --since "5 minutes ago" -p err --no-pager 2>/dev/null | wc -l)"
    if [ "$error_count" -gt 0 ]; then
        results+=("[WARN] Recent errors in log: $error_count")
    else
        results+=("[OK] No recent errors in log")
    fi

    # Check memory usage
    if [ -n "$main_pid" ] && [ "$main_pid" != "0" ] && [ -d "/proc/$main_pid" ]; then
        local mem_kb
        mem_kb="$(awk '/VmRSS/ {print $2}' /proc/"$main_pid"/status 2>/dev/null || echo 0)"
        local mem_mb=$((mem_kb / 1024))
        results+=("[INFO] Memory usage: ${mem_mb}MB")

        if [ "$mem_mb" -gt 512 ]; then
            results+=("[WARN] High memory usage")
        fi
    fi

    # Check frontend service if it exists
    if [ -f "$FRONTEND_SERVICE_FILE" ]; then
        if systemctl is-active "$FRONTEND_SERVICE_NAME.service" >/dev/null 2>&1; then
            results+=("[OK] Frontend service: active")

            # Check frontend health endpoint
            if command -v curl >/dev/null 2>&1; then
                local frontend_url="http://localhost:${DEFAULT_HMI_PORT}/"
                local frontend_code
                frontend_code="$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout "$HEALTH_CHECK_TIMEOUT" "$frontend_url" 2>/dev/null || echo "000")"
                if [ "$frontend_code" = "200" ]; then
                    results+=("[OK] Frontend responding: HTTP 200")
                elif [ "$frontend_code" = "000" ]; then
                    results+=("[WARN] Frontend not responding")
                else
                    results+=("[WARN] Frontend: HTTP $frontend_code")
                fi
            fi
        else
            results+=("[WARN] Frontend service: not active")
        fi
    fi

    # Print results
    echo ""
    echo "SERVICE HEALTH CHECK:"
    echo "====================="
    for check_result in "${results[@]}"; do
        echo "  $check_result"
    done
    echo "====================="
    echo ""

    if [ $failed -ne 0 ]; then
        log_error "Service health check failed"
        return 5
    fi

    log_info "Service health check passed"
    return 0
}

# =============================================================================
# Service Status
# =============================================================================

# Get detailed service status
# Returns: 0 on success
get_service_status() {
    log_info "Getting service status..."

    echo ""
    echo "=== Service Status ==="
    systemctl status "$SERVICE_NAME.service" --no-pager 2>&1 || true
    echo ""

    return 0
}

# =============================================================================
# Combined Functions
# =============================================================================

# Install and enable service
# Returns: 0 on success
setup_service() {
    local platform="${1:-generic}"
    local workers="${2:-auto}"

    log_info "Setting up service..."

    # Install service
    install_service "$platform" "$workers" || {
        log_error "Failed to install service"
        return 4
    }

    # Enable service
    enable_service || {
        log_error "Failed to enable service"
        return 4
    }

    log_info "Service setup complete"
    return 0
}

# Install, enable, and start service
# Returns: 0 on success
setup_and_start_service() {
    local platform="${1:-generic}"
    local workers="${2:-auto}"

    # Setup service
    setup_service "$platform" "$workers" || return 4

    # Start service
    start_service || return 4

    # Check health
    check_service_health || {
        log_warn "Health check failed, but service may still be starting"
    }

    return 0
}

# =============================================================================
# Uninstall
# =============================================================================

# Remove service completely
# Returns: 0 on success
uninstall_service() {
    log_info "Uninstalling service..."

    # Stop service if running
    stop_service 2>/dev/null || true

    # Disable service
    disable_service 2>/dev/null || true

    # Remove service file
    if [ -f "$SERVICE_FILE" ]; then
        sudo rm -f "$SERVICE_FILE"
        log_debug "Removed service file: $SERVICE_FILE"
    fi

    # Reload daemon
    sudo systemctl daemon-reload 2>/dev/null || true

    log_info "Service uninstalled"
    return 0
}

# =============================================================================
# Main Entry Point (when run directly)
# =============================================================================

if [ "${BASH_SOURCE[0]}" = "${0}" ]; then
    # Initialize logging
    init_logging || {
        echo "[WARN] Logging initialization failed" >&2
    }

    case "${1:-}" in
        --generate)
            generate_service_unit "${2:-generic}" "${3:-auto}"
            exit $?
            ;;
        --install)
            install_service "${2:-generic}" "${3:-auto}"
            exit $?
            ;;
        --enable)
            enable_service
            exit $?
            ;;
        --disable)
            disable_service
            exit $?
            ;;
        --start)
            start_service
            exit $?
            ;;
        --stop)
            stop_service
            exit $?
            ;;
        --restart)
            restart_service
            exit $?
            ;;
        --status)
            get_service_status
            exit $?
            ;;
        --health)
            check_service_health
            exit $?
            ;;
        --setup)
            setup_service "${2:-generic}" "${3:-auto}"
            exit $?
            ;;
        --setup-and-start)
            setup_and_start_service "${2:-generic}" "${3:-auto}"
            exit $?
            ;;
        --uninstall)
            uninstall_service
            exit $?
            ;;
        --help|-h)
            echo "Water-Controller Service Module v$SERVICE_MODULE_VERSION"
            echo ""
            echo "Usage: $0 [OPTION] [PLATFORM] [WORKERS]"
            echo ""
            echo "Options:"
            echo "  --generate [platform] [workers]   Generate service unit file"
            echo "  --install [platform] [workers]    Install systemd service"
            echo "  --enable                          Enable service for boot"
            echo "  --disable                         Disable service"
            echo "  --start                           Start service"
            echo "  --stop                            Stop service"
            echo "  --restart                         Restart service"
            echo "  --status                          Show service status"
            echo "  --health                          Run health check"
            echo "  --setup [platform] [workers]      Install and enable"
            echo "  --setup-and-start                 Install, enable, and start"
            echo "  --uninstall                       Remove service completely"
            echo "  --help, -h                        Show this help"
            echo ""
            echo "Arguments:"
            echo "  platform    Hardware platform (e.g., raspberry_pi_4, x86_64)"
            echo "  workers     Number of workers (default: auto-detect)"
            echo ""
            echo "Service: $SERVICE_NAME"
            echo "Port: $DEFAULT_API_PORT"
            ;;
        *)
            echo "Usage: $0 [--generate|--install|--enable|--start|--stop|--restart|--status|--health|--setup|--uninstall|--help]" >&2
            exit 1
            ;;
    esac
fi
